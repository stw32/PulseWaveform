# ISO Study Analysis Script:

setwd("Desktop/Scripts")

library(tidyverse)                                 
library(splines2)
library(pracma)
library(SplinesUtils) 
library(zoo)

source("~/Desktop/Scripts/PPG_funcs.R")
source("~/Desktop/Scripts/iso_funcs.R")

dir <- "~/Desktop/Khalsa_Fletcher_collaboration copy/Physio Dial/ISO_3.0/Iso_3_PhysioData/"
run_order <- read.csv("~/Desktop/PulseAnalysis/ISO_3_run_dose_order.txt", sep = "")
Participants <- GetParticipants(dir)

samplingRate <- 40
beats_in.m <- 10
batch_number <- 10
all_beats <- TRUE
subset <- TRUE
pk_thrshd <- 300

errors <- list()
AllOutputs<- list()
rejected_waves_list1 <- list()
rejected_waves_list3 <- list()
waves_carried_forward1 <- list()
waves_carried_forward3 <- list()

for(run in 1:length(Participants)){  
  
  errors[[run]] <- tryCatch(
    
    expr = {
      
      direc <- GetDirec(run, Participants, dir)
      pairs <- GetPairs(direc = direc[1], run_order, participant_number = run, subjectID = direc[2])
      
      temp <- FindUndetrendingParams(direc = direc[1], gs = model2.GetSegment, oa = OffsetAdjust, fa = FactorAdjust, u = UnDetrend, factorCutoff = 0, sr = samplingRate, pairs = pairs, pk_thrshd = pk_thrshd, plot = F)
      factor_value <- temp[1]
      offset_value <- temp[2]
      
      Outputs <- list()
      for(ps in 1:2){
        
        if(ps == 1){pair <- pairs[[1]]}else{pair <- pairs[[2]]}
        
        for(pr in 1:2){
          beats_in <- beats_in.m   
          new_direc <- paste(direc[1], "/", pair[pr], sep = "")
          
          # If on the 2nd (i.e placebo) run, pass boundaries in to subsetting:
          if(pr == 2){subset <- "rep"}
          if(pr == 1){
            subset <- TRUE
            boundaries = NULL
          }
          
          # Load time series:
          ppg <- read.csv(new_direc, sep = "")   
          ppg <- data.frame(
            time = (0:(nrow(ppg)-1)) / samplingRate,
            ppg = ppg[,1]
          )
          names(ppg)[1] <- "time (s)"
          names(ppg)[2] <- "Detrended"
          
          
          # Define beat:  
          n <- dim(ppg)[1]
          vpg <- ppg[2:n,2] - ppg[1:(n-1),2]
          beat <- data.frame(ppg[which(vpg[1:(n-1)] < pk_thrshd & vpg[2:n] >= pk_thrshd),1])  
          rm(vpg)
          
          # Apply factor and offset:
          ppg[,2] = UnDetrend(ppg,factor=factor_value,offset=offset_value)  
          
          # Check time series:
          # plot(ppg[,1],ppg[,2],t='l')
          
          # Run main script, find peaks using find_w, generate segments from O values, correct baseline:
          undetrended <- ppg[, 2]
          sfunction <- splinefun(1:length(undetrended), undetrended, method = "natural")
          deriv1 <- sfunction(seq(1, length(undetrended)), deriv = 1)
          spline1 <-  sfunction(seq(1, length(undetrended)), deriv = 0)
          splinePoly <- CubicInterpSplineAsPiecePoly(1:length(undetrended), undetrended, "natural")
          deriv1Poly <- CubicInterpSplineAsPiecePoly(1:length(undetrended), deriv1, "natural") 
          inflexX <- solve(splinePoly, b = 0, deriv = 1)
          inflexY <- predict(splinePoly, inflexX)
          w <- find_w(d1p = deriv1Poly, deriv1 = deriv1, sp = splinePoly, sr = samplingRate)
          uv <- find_u_v(wx = w$wX, wy = w$wY, d1 = deriv1, d1p = deriv1Poly, spline = splinePoly, plot=F)
          tmp <- find_o(wx = w$wX, inx = inflexX, iny = inflexY, d1p = deriv1Poly, sp = splinePoly)  
          inflexX <- tmp[[1]]
          inflexY <- tmp[[2]]
          o_orig <- tmp[[3]]  
          tmp <- preclean_wuv(w=w, uv=uv, o=o_orig, samp = samplingRate, sp = spline1, q = F)   
          w <- tmp[[1]]
          uv <- tmp[[2]]
          o <- tmp[[3]]
          rm(tmp)
          baseCor <- baseline(inx = inflexX, iny = inflexY, o = o_orig, dat = undetrended, sp = splinePoly, plot=F)
          sfunctionBC <- splinefun(1:length(baseCor), baseCor, method = "natural")
          deriv1BC <- sfunctionBC(seq(1, length(baseCor)), deriv = 1)
          spline1BC <- sfunctionBC(seq(1, length(baseCor)), deriv = 0)
          splinePolyBC <- CubicInterpSplineAsPiecePoly(1:length(baseCor), baseCor, "natural")
          deriv1PolyBC <- CubicInterpSplineAsPiecePoly(1:length(baseCor), deriv1BC, "natural") 
          w$wY <- predict(splinePolyBC, w$wX)
          uv$uY <- predict(splinePolyBC, uv$uX)
          uv$vY <- predict(splinePolyBC, uv$vX)
          wuv <- cbind(w, uv)
          tmp <- clean_wuv(wuv = wuv, sp = splinePolyBC, inx = inflexX, o = o, samp = samplingRate, bc = baseCor, q = F)   
          wuv <- tmp[[1]]
          ibi <- tmp[[2]]
          oDiff <- tmp[[3]]
          rm(tmp, w, uv)
          waveLen <- round(median(oDiff)+15) 
          ppg[, 2] <- baseCor
          tmp <- sep_beats(odiff = oDiff, bc = baseCor, samp = samplingRate, wuv = wuv, wvlen = waveLen, ibi=ibi, o=o_orig, inx = inflexX, scale = T, q = F, subset, boundaries) 
          pulse <- tmp[[2]]
          avWave <- tmp[[1]]
          wuv <- tmp[[3]]
          rejects <- tmp[[4]]
          if(subset == T){boundaries <- tmp[[5]]}
          rm(tmp)
          
          # Check time series:
          # plot(ppg$`time (s)`[1:7500], ppg$Detrended[1:7500], type = "l")
          # points(ppg[inflexX[o], 1], rep(0, length(inflexX[o])))
          
          # Save rejected beats and waves carried forward:
          if(pr == 1){
            if(ps == 1){
              rejected_waves_list1[[run]] <- rejects
              waves_carried_forward1[run] <- boundaries[2]
            }else{
              rejected_waves_list3[[run]] <- rejects
              waves_carried_forward3[run] <- boundaries[2]
            }
          }
         
          
          # Create beat dataframe and add output columns: 
          beat <-  ppg[round(inflexX[wuv$o2]), 1]   
          nBeats <- length(beat)    
          beat <- data.frame(
            beat = beat,
            dt = (1:nBeats)*0.0
          )
          beat <- AddOutput(beat)
          if(all_beats == T){
            batch_number <- floor(nrow(beat)/beats_in)    
            remainder <- nrow(beat) - (batch_number*beats_in)
          }
          
          # Add output columns to ppg:
          ppg$Baseline = 1:nrow(ppg) * 0
          ppg$Excess   = 1:nrow(ppg) * 0
          ppg$Residue  = 1:nrow(ppg) * 0
          
          # Fill beat and ppg with parameters derived from the excess:
          temp <- FindStartParams(batch_number, beats_in, beat, ppg, gs = model2.GetSegment, e = model2.Excess, sep = model2.SubtractExcessPeak, o_points = inflexX[o_orig], wuv = wuv, inflexX = inflexX, all_beats)
          beat <- temp[[1]]
          ppg <- temp[[2]]
          rm(temp)
          
          # Make and run simplex for each batch:
          beat_orig <- beat
          fit_check <- list()
          for(k in 1:(batch_number+1)){         
            
            if(all_beats == TRUE){
              if(k == batch_number+1){
                if(remainder == 0){break}
                beat <- beat_orig[(((k-1)*beats_in) + 1 ):(((k-1)*beats_in) + remainder), ]
                beats_in <- remainder
                w <- wuv$wX[(((k-1)*beats_in) + 1 ):(((k-1)*beats_in) + remainder)]
              }else{
                beat <- beat_orig[((k*beats_in)-(beats_in-1)):(k*beats_in), ]
                w <- wuv$wX[((k*beats_in)-(beats_in-1)):(k*beats_in)]
              }
            }else{
              beat <- beat_orig[((k*beats_in)-(beats_in-1)):(k*beats_in), ]
              w <- wuv$wX[((k*beats_in)-(beats_in-1)):(k*beats_in)]
            }
            
            w <- w / samplingRate
            renal_param <- median(beat$NTime)
            dias_param <- median(beat$DTime)
            sys_time <- beat$STime
            par <- as.numeric(beat[1,5:16])   
            beat_start <- beat[, 3]
            beat_end <- beat[, 4]
            beat_vector <- list(beats_in, beat_start, beat_end)
            
            # Refine parameters:
            for(i in 1:4){
              if(i == 1){new_beat <- beat}
              within_params <- FindWithinParams(beats_in, ppg, beat = new_beat, gs = model2.GetSegment, fp = model2.FixParams3, ms = simplex.MakeSimplex3, m2 = model2.ChiSq3, beat_vector = beat_vector, renal_param = renal_param, dias_param = dias_param, sys_time = sys_time, w = w)
              across_params <- simplex.MakeSimplex2(data=ppg, param = par, f = model2.ChiSq3, inScale = 0.1, beat_vector = beat_vector, beat = new_beat, renal_param = renal_param, dias_param = dias_param, sys_time = sys_time, w = w)
              mat <- make_matrix(across_params, within_params)
              sim <- simplex.Run2(data = ppg, simplexParam = mat, f = model2.ChiSq3, optional=NULL, beat_vector = beat_vector, renal_param = renal_param, dias_param = dias_param, sys_time = sys_time, w = w, run = c("run", i))
              output <- extractOutput(beats_in, sim)
              fixed <- FixOutput(beats_in, beat = new_beat, ppg, gs = model2.GetSegment, fp = model2.FixParams3, across = output[[1]], within = output[[2]], sys_time = sys_time)
              new_beat <- UpdateBeat(beats_in, beat, fixed)
              new_beat <- FixBaseline(new_beat, f = model2.ChiSq4, renal_param, dias_param, sys_time, w)
            }
            
            # Assess fit:
            fit_check[[k]] <- model2.ChiSq4(data = ppg, params = NULL, beats = beat_vector, beat = new_beat, a = sim[1, ], plot = FALSE, renal_param = renal_param, dias_param = dias_param, sys_time = sys_time, w = w) 
            
            # Finalise:
            beat2 <- new_beat       
            colnames(beat2) <- colnames(beat)
            beat2 <- beat2[, -c(1:4)]
            
            # Plot
            #PlotFits(beats_in, ppg, beat2, gs = model2.GetSegment, rb = model2.Rebuild2)
            
            # Add to overall beat:
            if(k == 1){beat_final <- beat2}else{beat_final <- rbind(beat_final, beat2)}
            
          }
          
          # Complete main script to find OSND and morphological features:
          polyWave <- list()
          for(i in 2:ncol(pulse)){
            polyWave[[i-1]] <-CubicInterpSplineAsPiecePoly(pulse$x, pulse[, i], "natural")
          }
          tmp <- diast_pk(avw = avWave, sr = samplingRate, scale = T)
          dPeak <- tmp[1]
          xShift <- tmp[2]
          rm(tmp)
          osnd <- osnd_of_average(avWave, dp = dPeak, diff = 0, sr = samplingRate)
          if(dPeak == 5*samplingRate){
            dPeak <- osnd$x[4]*1.2 
          }
          if((osnd$x[4]-osnd$x[3]) < 1.5 & (osnd$x[4]-osnd$x[3]) > 0){
            dPeak <- dPeak*0.95
            osnd <- osnd_of_average(avWave, dp = dPeak, diff = 0, sr = samplingRate)
          }
          scale <- 1   # Set to 1 if scaling
          osnd_all <- list()
          for(i in 2:ncol(pulse)){  #ncol(pulse)
            wavi <- pulse[, i][!is.na(pulse[, i])]
            if(scale == 1){
              xShift2 <- (which(abs(wavi - 0.5) == min(abs(wavi - 0.5))))  # the new 0.5 
            }else{
              xShift2 <- which.min(abs(wavi))
            }
            diff <- xShift - xShift2
            dpa <- dPeak - diff
            osnd_all[[i-1]] <- osnd_of_average(aw = wavi, dp = dpa, diff = diff, sr = samplingRate, plot = F) 
          }
          # Can plot all OSND values against the average to see if there are any obvious anomalies:
          plot(avWave[!is.na(avWave)], type = "l")
          for(i in 1:length(osnd_all)){
            points(osnd_all[[i]][4, 1], osnd_all[[i]][4, 2], col = "blue")
            points(osnd_all[[i]][3, 1], osnd_all[[i]][3, 2], col = "red")
            points(osnd_all[[i]][2, 1], osnd_all[[i]][2, 2])
            points(osnd_all[[i]][1, 1], osnd_all[[i]][1, 2])
          }
          # Extract morphological features:
          for(i in 1:length(osnd_all)){
            osnd_all[[i]]$y <- osnd_all[[i]]$y - osnd_all[[i]]$y[1]
          }
          features <- feature_extract(oa = osnd_all, p = pulse, pw = polyWave)
          
          # Add first four columns to beat final:
          beat_final <- cbind(beat_orig[1:nrow(beat_final), 1:4], beat_final)
          # Calculate differnces in OSND
          osnd_fits <- osnd_fit(beat_final, ppg, plot = F)    
          
          # Output:
          if(ps == 1){
            if(pr == 1){otpt <- 1}else{otpt <- 2}
          }else{
            if(pr == 1){otpt <- 3}else{otpt <- 4}
          }
          temp <- ArrangeOutputs(beat_final, beat_orig, features, pulse, fit_check, ps, pr)
          Outputs[[otpt]] <- list(temp[[1]], temp[[2]], temp[[3]], osnd_fits, osnd_all, avWave, osnd, pulse, polyWave)
          
        }
      }
      
      # Plotting average waves of 0mg vs 2mg (pair 1):
      plot(Outputs[[1]][[6]], type = "l", col = "red", xlim = c(100, 500))    
      lines(Outputs[[2]][[6]])
      # Plotting average waves of 0mg vs 2mg (pair 2):
      plot(Outputs[[3]][[6]], type = "l", col = "red", xlim = c(100, 500))    
      lines(Outputs[[4]][[6]])
      
      AllOutputs[[run]] <- Outputs
      return <- NULL
      
    },
    error = function(e){
      message('Caught an error!')
      message(e)
      return(e)
    }, 
    warning = function(w){
      message('Caught a warning!')
      message(w)
      return(w)
    },
    finally = {
      message('All done with current participant.')
    }
    
  )
  
}

# Check Errors:
non_null_names <- which(!sapply(errors, is.null))
errors <- errors[non_null_names]
names(errors) <- non_null_names
print(errors)

# Plot waves carried over and rejected waves:
PlotRejects(rejected_waves_list1, rejected_waves_list3)
PlotWavesCarriedForward(waves_carried_forward1, waves_carried_forward3)

# Check Outputs:

# e.g AllOutputs[[11]][[4]][[6]]  = participant 11, time series 4, avWave

# last two double-brackets key:

# [[i]][[1]] == beat_final
# [[i]][[2]] == features
# [[i]][[3]] == fit_check
# [[i]][[4]] == osnd_fits
# [[i]][[5]] == osnd_all
# [[i]][[6]] == avWave
# [[i]][[7]] == osnd (of average)
# [[i]][[8]] == pulse
# [[i]][[9]] == polyWave

# 2mg: i = 1 and i = 3
# 0mg: i = 2 and i = 4 

# e.g
plot(AllOutputs[[11]][[4]][[6]])
